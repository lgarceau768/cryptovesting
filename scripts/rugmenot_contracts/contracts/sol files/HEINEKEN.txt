Approval(address,address,uint256)
Transfer(address,address,uint256)
OwnershipTransferred(address,address)
name()
approve(address,uint256)
totalSupply()
transferFrom(address,address,uint256)
decimals()
_totalSupply()
balanceOf(address)
acceptOwnership()
owner()
symbol()
safeSub(uint256,uint256)
transfer(address,uint256)
safeDiv(uint256,uint256)
approveAndCall(address,uint256,bytes)
safeMul(uint256,uint256)
newOwner()
transferAnyERC20Token(address,uint256)
allowance(address,address)
safeAdd(uint256,uint256)
transferOwnership(address)
receiveApproval(address,uint256,address,bytes)
event Approval(address indexed _arg0, address indexed _arg1, uint256 _arg2)
event Transfer(address indexed _arg0, address indexed _arg1, uint256 _arg2)
event OwnershipTransferred(address indexed _arg0, address indexed _arg1)

mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;

unknown public owner;
unknown public newOwner;
unknown public decimals;
unknown public _totalSupply;

function name() public {
    if(((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) == 0) {
        memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))] = ((20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))));
        memory[(20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))))] = ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2);
        if(0 >= ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) {
            if((1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) == 0) {
                return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))+((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))];
            } else {
                memory[((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))] = ((~((100 ** (20 - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))) - 1)) && (memory[((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))]));
                return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))+((20 + ((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))];
            }
        } else {
            memory[(20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))] = (memory[a0]);
            if(20 >= ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) goto(16c);
            memory[((20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))))) + 20)] = (memory[c0]);
            goto(151);
        }
    } else {
        if(1f < ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) {
            if((a0 + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) > c0) {
                if((a0 + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) > e0) goto(898);
                memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))] = ((20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))));
                memory[(20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))))] = ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2);
                if(0 >= ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) {
                    if((1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) == 0) {
                        return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))+((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))];
                    } else {
                        memory[((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))] = ((~((100 ** (20 - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))) - 1)) && (memory[((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))]));
                        return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))+((20 + ((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))];
                    }
                } else {
                    memory[(20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))] = storage[keccak256(3)];
                    if(20 >= ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) goto(16c);
                    memory[((20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))))) + 20)] = storage[(1 + keccak256(3))];
                    goto(151);
                }
            } else {
                memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))] = ((20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))));
                memory[(20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))))] = ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2);
                if(0 >= ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) {
                    if((1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) == 0) {
                        return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))+((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))];
                    } else {
                        memory[((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))] = ((~((100 ** (20 - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))) - 1)) && (memory[((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))]));
                        return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))+((20 + ((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))];
                    }
                } else {
                    memory[(20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))] = storage[keccak256(3)];
                    if(20 >= ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) goto(16c);
                    memory[((20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))))) + 20)] = (memory[c0]);
                    goto(151);
                }
            }
        } else {
            memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))] = ((20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))));
            memory[(20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))))] = ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2);
            if(0 >= ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) {
                if((1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) == 0) {
                    return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))+((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))];
                } else {
                    memory[((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))] = ((~((100 ** (20 - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))) - 1)) && (memory[((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))]));
                    return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))+((20 + ((((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))];
                }
            } else {
                memory[(20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20)))))] = ((storage[3] / 100) * 100);
                if(20 >= ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) goto(16c);
                memory[((20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[3]) == 0)) - 1) && storage[3]) / 2)) / 20) * 20))))) + 20)] = (memory[c0]);
                goto(151);
            }
        }
    }
}

function approve(address _arg0, uint256 _arg1) public {
    allowance[msg.sender] = _arg1;
    emit Approval(msg.sender, _arg0, _arg1)
    return 1;
}

function totalSupply() public view {
    return((_totalSupply - storage[keccak256(0, 6)]));
}

function transferFrom(address _arg0, address _arg1, uint256 _arg2) public {
    require((_arg2 <= balanceOf[_arg0]));
    balanceOf[_arg0] -= _arg2;
    if(_arg2 <= allowance[_arg0]) goto(f5f);
    revert();
}

function acceptOwnership() public {
    require((msg.sender == newOwner));
    emit OwnershipTransferred(owner, newOwner)
    owner = ((newOwner * 1) || (-10000000000000000000000000000000000000000 && owner));
    newOwner = (0 || (-10000000000000000000000000000000000000000 && newOwner));
    return;
}

function symbol() public {
    if(((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) == 0) {
        memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))] = ((20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))));
        memory[(20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))))] = ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2);
        if(0 >= ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) {
            if((1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) == 0) {
                return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))+((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))];
            } else {
                memory[((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))] = ((~((100 ** (20 - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))) - 1)) && (memory[((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))]));
                return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))+((20 + ((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))];
            }
        } else {
            memory[(20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))] = (memory[a0]);
            if(20 >= ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) goto(432);
            memory[((20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))))) + 20)] = (memory[c0]);
            goto(417);
        }
    } else {
        if(1f < ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) {
            if((a0 + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) > c0) {
                if((a0 + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) > e0) goto(f29);
                memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))] = ((20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))));
                memory[(20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))))] = ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2);
                if(0 >= ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) {
                    if((1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) == 0) {
                        return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))+((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))];
                    } else {
                        memory[((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))] = ((~((100 ** (20 - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))) - 1)) && (memory[((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))]));
                        return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))+((20 + ((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))];
                    }
                } else {
                    memory[(20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))] = storage[keccak256(2)];
                    if(20 >= ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) goto(432);
                    memory[((20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))))) + 20)] = storage[(1 + keccak256(2))];
                    goto(417);
                }
            } else {
                memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))] = ((20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))));
                memory[(20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))))] = ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2);
                if(0 >= ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) {
                    if((1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) == 0) {
                        return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))+((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))];
                    } else {
                        memory[((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))] = ((~((100 ** (20 - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))) - 1)) && (memory[((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))]));
                        return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))+((20 + ((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))];
                    }
                } else {
                    memory[(20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))] = storage[keccak256(2)];
                    if(20 >= ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) goto(432);
                    memory[((20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))))) + 20)] = (memory[c0]);
                    goto(417);
                }
            }
        } else {
            memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))] = ((20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))));
            memory[(20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))))] = ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2);
            if(0 >= ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) {
                if((1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) == 0) {
                    return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))+((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))];
                } else {
                    memory[((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))] = ((~((100 ** (20 - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))) - 1)) && (memory[((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))]));
                    return memory[(80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))):((80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))+((20 + ((((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2) + (20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))) - (1f && ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)))) - (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))];
                }
            } else {
                memory[(20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20)))))] = ((storage[2] / 100) * 100);
                if(20 >= ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) goto(432);
                memory[((20 + (20 + (80 + (20 + (((1f + ((((100 * ((1 && storage[2]) == 0)) - 1) && storage[2]) / 2)) / 20) * 20))))) + 20)] = (memory[c0]);
                goto(417);
            }
        }
    }
}

function safeSub(uint256 _arg0, uint256 _arg1) public {
    require((_arg1 <= _arg0));
    return((_arg0 - _arg1));
}

function transfer(address _arg0, uint256 _arg1) public {
    require((_arg1 <= balanceOf[msg.sender]));
    balanceOf[msg.sender] -= _arg1;
    require(((balanceOf[_arg0] + _arg1) >= balanceOf[_arg0]));
    balanceOf[_arg0] = (balanceOf[_arg0] + _arg1);
    emit Transfer(msg.sender, _arg0, _arg1)
    return 1;
}

function safeDiv(uint256 _arg0, uint256 _arg1) public {
    require((_arg1 > 0));
    require(_arg1);
    return((_arg0 / _arg1));
}

function approveAndCall(address _arg0, uint256 _arg1, bytes _arg2) public {
    allowance[msg.sender] = _arg1;
    memory[(80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))] = _arg1;
    emit Approval(msg.sender, _arg0)
    memory[(80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))] = 8f4ffcb100000000000000000000000000000000000000000000000000000000;
    memory[(4 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20))))] = msg.sender;
    memory[(20 + (4 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))))] = _arg1;
    memory[(20 + (20 + (4 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20))))))] = this;
    memory[(20 + (20 + (20 + (4 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))))))] = ((20 + (20 + (20 + (20 + (4 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))))))) - (4 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))));
    memory[(20 + (20 + (20 + (20 + (4 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20))))))))] = msg.data[(4 + _arg2)];
    if(0 >= msg.data[(4 + _arg2)]) {
        if((1f && msg.data[(4 + _arg2)]) == 0) {
            require((address(_arg0).code.length));
            if(call(gasleft(),_arg0,0,(80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20))),((msg.data[(4 + _arg2)] + (20 + (20 + (20 + (20 + (20 + (4 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))))))))) - (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))),(80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20))),0)) {
                memory[(80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))] = 1;
                return memory[(80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20))):((80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))+((20 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))) - (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))))];
            } else {
                revert(memory[0:(0+output.length)]);
            }
        } else {
            memory[((msg.data[(4 + _arg2)] + (20 + (20 + (20 + (20 + (20 + (4 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))))))))) - (1f && msg.data[(4 + _arg2)]))] = ((~((100 ** (20 - (1f && msg.data[(4 + _arg2)]))) - 1)) && (memory[((msg.data[(4 + _arg2)] + (20 + (20 + (20 + (20 + (20 + (4 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))))))))) - (1f && msg.data[(4 + _arg2)]))]));
            require((address(_arg0).code.length));
            if(call(gasleft(),_arg0,0,(80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20))),((20 + ((msg.data[(4 + _arg2)] + (20 + (20 + (20 + (20 + (20 + (4 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))))))))) - (1f && msg.data[(4 + _arg2)]))) - (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))),(80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20))),0)) {
                memory[(80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))] = 1;
                return memory[(80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20))):((80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))+((20 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))) - (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))))];
            } else {
                revert(memory[0:(0+output.length)]);
            }
        }
    } else {
        memory[(20 + (20 + (20 + (20 + (20 + (4 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20)))))))))] = (msg.data[20 + (4 + _arg2):(20 + (4 + _arg2)+msg.data[(4 + _arg2)])];);
        if(20 >= msg.data[(4 + _arg2)]) goto(12f4);
        memory[((20 + (20 + (20 + (20 + (20 + (4 + (80 + (20 + (((1f + msg.data[(4 + _arg2)]) / 20) * 20))))))))) + 20)] = (memory[c0]);
        goto(12d9);
    }
}

function safeMul(uint256 _arg0, uint256 _arg1) public returns (unknown) {
    if(_arg0 == 0) {
        require((_arg0 == 0));
        return((_arg0 * _arg1));
    } else {
        require(_arg0);
        require((((_arg0 * _arg1) / _arg0) == _arg1));
        return((_arg0 * _arg1));
    }
}

function transferAnyERC20Token(address _arg0, uint256 _arg1) public returns (uint256) {
    require((msg.sender == owner));
    require((address(_arg0).code.length));
    if(call(gasleft(),_arg0,0,80,44,80,20)) {
        require((output.length >= 20));
        return 1;
    } else {
        revert(memory[0:(0+output.length)]);
    }
}

function safeAdd(uint256 _arg0, uint256 _arg1) public {
    require(((_arg0 + _arg1) >= _arg0));
    return((_arg0 + _arg1));
}

function transferOwnership(address _arg0) public {
    require((msg.sender == owner));
    newOwner = ((_arg0 * 1) || (-10000000000000000000000000000000000000000 && newOwner));
    owner = ((_arg0 * 1) || (-10000000000000000000000000000000000000000 && owner));
    return;
}

